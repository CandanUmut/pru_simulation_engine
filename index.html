<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PRU Universe · Web Sandbox</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #05070c;
      --panel: #0f1219;
      --panel-border: #1f2430;
      --accent: #6ad8ff;
      --accent-2: #ff9f6b;
      --text: #d6e2ff;
      --muted: #7c8aa6;
      --green: #5ee1a5;
      --yellow: #ffd166;
      --red: #ff6b81;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0; padding: 0;
      height: 100%;
      background: radial-gradient(circle at top, #141b33 0%, var(--bg) 45%, #020308 100%);
      color: var(--text);
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    body { display: flex; overflow: hidden; }
    #scene-container { flex: 1; position: relative; }

    #overlay-title {
      position: absolute;
      top: 18px; left: 18px;
      background: rgba(5, 8, 16, 0.82);
      padding: 12px 14px;
      border-radius: 10px;
      border: 1px solid var(--panel-border);
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      backdrop-filter: blur(10px);
    }
    #overlay-title h1 {
      margin: 0;
      font-size: 22px;
      letter-spacing: 0.02em;
    }
    #overlay-title p {
      margin: 4px 0 0;
      color: var(--muted);
      font-size: 12px;
    }

    #panel {
      width: 380px;
      background: radial-gradient(circle at top, #151828 0%, var(--panel) 35%, #05060b 100%);
      border-left: 1px solid var(--panel-border);
      padding: 16px 16px 18px;
      overflow-y: auto;
      box-shadow: -12px 0 30px rgba(0,0,0,0.55);
    }

    .section {
      padding: 12px 0;
      border-bottom: 1px solid var(--panel-border);
    }
    .section:last-child { border-bottom: none; }
    .section h3 {
      margin: 0 0 6px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 11px;
      color: var(--muted);
    }

    .phase-row {
      display: flex;
      justify-content: space-between;
      margin: 4px 0;
      font-size: 13px;
    }

    .controls button {
      margin-right: 6px;
      margin-bottom: 6px;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--panel-border);
      background: #161a24;
      color: var(--text);
      cursor: pointer;
      transition: border-color 0.15s, background 0.15s, transform 0.08s;
      font-size: 13px;
    }
    .controls button:hover {
      border-color: var(--accent);
      background: #1b2434;
      transform: translateY(-1px);
    }
    .controls button:active {
      transform: translateY(0);
    }

    .controls .segmented {
      display: inline-flex;
      border: 1px solid var(--panel-border);
      border-radius: 10px;
      overflow: hidden;
      background: #111623;
      flex-wrap: wrap;
    }
    .controls .segmented button {
      margin: 0;
      border: none;
      border-right: 1px solid var(--panel-border);
      border-radius: 0;
      background: transparent;
      padding: 7px 10px;
      font-size: 12px;
    }
    .controls .segmented button:last-child { border-right: none; }
    .controls .segmented button.active {
      background: linear-gradient(135deg, #19324a, #132130);
      color: #cceaff;
    }

    label.small {
      display: block;
      font-size: 11px;
      color: var(--muted);
      margin: 6px 0 2px;
    }
    .toggle {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--panel-border);
      background: #161a24;
      width: 100%;
      text-align: left;
      cursor: pointer;
      font-size: 13px;
    }
    .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .row + .row { margin-top: 8px; }

    input[type=range] {
      width: 100%;
      accent-color: var(--accent);
    }

    .hud-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      font-size: 13px;
    }
    .hud-grid div {
      background: #0f1219;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid var(--panel-border);
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 6px;
    }
    .hud-grid strong { color: var(--accent-2); font-weight: 600; }

    #sparkline {
      width: 100%;
      height: 50px;
      background: #0c1018;
      border: 1px solid var(--panel-border);
      border-radius: 8px;
      margin-top: 4px;
      display: block;
    }

    #agents {
      background: #0f1219;
      border: 1px solid var(--panel-border);
      border-radius: 8px;
      padding: 8px 9px;
      height: 120px;
      overflow-y: auto;
      font-size: 13px;
      line-height: 1.4;
    }

    #inspector-details {
      background: #0f1219;
      border: 1px solid var(--panel-border);
      border-radius: 8px;
      padding: 8px 9px;
      font-size: 12px;
      line-height: 1.5;
      margin-top: 4px;
      white-space: pre-line;
    }

    .badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 11px;
      background: #162034;
      border: 1px solid var(--panel-border);
    }

    .text-muted { color: var(--muted); }
    .small-help p {
      margin: 4px 0;
      font-size: 11px;
      color: var(--muted);
    }
    a { color: var(--accent); }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="scene-container">
    <div id="overlay-title">
      <h1>PRU Universe · Web Sandbox</h1>
      <p>Precomputed Relational Universe (Three.js demo)</p>
    </div>
  </div>

  <aside id="panel">
    <div class="section" id="phase-status">
      <h3>Phase Status</h3>
      <div class="phase-row"><span>Phase 1: Core Scaffold</span><span>✅</span></div>
      <div class="phase-row"><span>Phase 2: Fields & Overlays</span><span>✅</span></div>
      <div class="phase-row"><span>Phase 3: Gravity & LSS</span><span>⏳</span></div>
      <div class="phase-row"><span>Phase 4: Stars & Agents</span><span>⏳</span></div>
      <div class="phase-row"><span>Phase 5: Time Control & Presets</span><span>TODO</span></div>
    </div>

    <div class="section controls" id="sim-controls">
      <h3>Simulation Controls</h3>
      <div>
        <button id="pause-btn">Pause</button>
        <button id="step-btn">Step</button>
      </div>
      <div>
        <button id="slower-btn">Slower</button>
        <button id="faster-btn">Faster</button>
      </div>
      <label class="small">Global time scale</label>
      <input type="range" id="timescale-slider" min="0.05" max="8" step="0.05" value="1.0">
      <div class="row"><span class="text-muted">Current</span><span id="timescale-label">1.0×</span></div>
    </div>

    <div class="section controls" id="presets">
      <h3>Experiment Presets</h3>
      <div class="segmented" id="preset-buttons">
        <button data-preset="random" class="active">Random Gas</button>
        <button data-preset="cluster">Central Cluster</button>
        <button data-preset="filaments">Cosmic Web</button>
        <button data-preset="shells">Voids & Shells</button>
      </div>
      <label class="small">Current preset: <span id="preset-label">Random Gas</span></label>
    </div>

    <div class="section controls" id="scale-modes">
      <h3>Scale Modes</h3>
      <div class="segmented" id="scale-mode-buttons">
        <button data-scale="lattice" class="active">PRU Lattice</button>
        <button data-scale="solar_system">Solar System</button>
        <button data-scale="galaxy">Galaxy Orbit</button>
      </div>
      <label class="small">Switch between lattice, solar system, and galaxy-scale views.</label>
    </div>

    <div class="section controls" id="overlays">
      <h3>Overlays</h3>
      <div class="segmented" id="overlay-buttons">
        <button data-mode="base" class="active">Base</button>
        <button data-mode="density">Density</button>
        <button data-mode="curvature">Curvature</button>
      </div>
      <label class="small">Density from UA (mass lock)</label>
      <label class="small">Curvature from UB + neighbors</label>
    </div>

    <div class="section controls" id="gravity">
      <h3>Gravity</h3>
      <button class="toggle" id="gravity-toggle">Gravity: OFF</button>
      <label class="small">Mode</label>
      <div class="segmented" id="gravity-mode">
        <button data-mode="naive" class="active">Naive N-body</button>
        <button data-mode="relational">Relational Lattice</button>
      </div>
      <label class="small">G (constant)</label>
      <input type="range" id="g-slider" min="0.1" max="5" step="0.1" value="1.2">
      <div class="row"><span class="text-muted">Value</span><span id="g-label">1.2</span></div>
      <label class="small">Damping</label>
      <input type="range" id="damping-slider" min="0" max="0.2" step="0.005" value="0.02">
      <div class="row"><span class="text-muted">Value</span><span id="damping-label">0.02</span></div>
      <label class="small">Softening</label>
      <input type="range" id="softening-slider" min="0.1" max="3" step="0.1" value="1.0">
      <div class="row"><span class="text-muted">Value</span><span id="softening-label">1.0</span></div>
    </div>

    <div class="section" id="metrics">
      <h3>Metrics HUD</h3>
      <div class="hud-grid">
        <div><span>Tick</span><strong id="tick-label">0</strong></div>
        <div><span>Sim t</span><strong id="simtime-label">0.00s</strong></div>
        <div><span>Cells</span><strong id="cell-label">0</strong></div>
        <div><span>ΔE/E0</span><strong id="energy-drift">0</strong></div>
        <div><span>Avg ρ</span><strong id="density-avg">0</strong></div>
        <div><span>Min/Max ρ</span><strong id="density-minmax">0 / 0</strong></div>
        <div><span>Avg κ</span><strong id="curv-avg">0</strong></div>
        <div><span>Energy</span><strong id="energy-breakdown">0</strong></div>
      </div>
      <div class="row" style="margin-top:10px;">
        <span class="text-muted">Density sparkline</span>
        <span class="badge">Rolling avg</span>
      </div>
      <canvas id="sparkline" width="320" height="50"></canvas>
    </div>

    <div class="section" id="inspector-section">
      <h3>Cell Inspector</h3>
      <div class="text-muted" id="inspector-hint">Click a cell in the lattice to inspect its PRU state.</div>
      <div id="inspector-details">No cell selected.</div>
    </div>

    <div class="section" id="solar-editor">
      <h3>Solar System Editor</h3>
      <label class="small">Active body</label>
      <select id="solar-body-select"></select>

      <label class="small">Solar physics mode</label>
      <div class="segmented" id="solar-physics-mode">
        <button data-mode="analytic" class="active">Analytic</button>
        <button data-mode="nbody">N-body</button>
      </div>

      <label class="small">Orbit radius</label>
      <input type="range" id="solar-orbit-radius" min="5" max="40" step="0.5">
      <div class="row"><span class="text-muted">Value</span><span id="solar-orbit-radius-label"></span></div>

      <label class="small">Orbit period (s)</label>
      <input type="range" id="solar-orbit-period" min="5" max="120" step="1">
      <div class="row"><span class="text-muted">Value</span><span id="solar-orbit-period-label"></span></div>

      <label class="small">Planet size</label>
      <input type="range" id="solar-radius" min="0.2" max="2.0" step="0.1">
      <div class="row"><span class="text-muted">Value</span><span id="solar-radius-label"></span></div>
    </div>

    <div class="section" id="galaxy-tools" style="display:none;">
      <h3>Galaxy Tools</h3>
      <label class="small">Insert object</label>
      <div class="segmented" id="galaxy-insert-mode">
        <button data-object="star_system" class="active">Star System</button>
        <button data-object="black_hole">Black Hole</button>
      </div>

      <label class="small">Orbit radius</label>
      <input type="range" id="galaxy-object-radius" min="10" max="120" step="2">
      <div class="row">
        <span class="text-muted">Value</span>
        <span id="galaxy-object-radius-label"></span>
      </div>

      <button id="galaxy-insert-btn">Add to galaxy</button>
    </div>

    <div class="section" id="agents-section">
      <h3>Astro Agents (Phase 4 preview)</h3>
      <div id="agents"></div>
    </div>

    <div class="section" id="help">
      <h3>Help & Shortcuts</h3>
      <div class="small-help">
        <p>Space – Pause/Resume · . – Step · -/+ – Slower/Faster</p>
        <p>D/C – Density/Curvature overlays · G – Toggle gravity</p>
        <p>Click any cube to inspect its UA/UB, density, curvature & agent state.</p>
      </div>
    </div>
  </aside>

  <script type="module">
  import * as THREE from "https://unpkg.com/three@0.164.1/build/three.module.js";
  import { OrbitControls } from "https://unpkg.com/three@0.164.1/examples/jsm/controls/OrbitControls.js?module";

  try {
    // --------- Scene setup ---------
    const container = document.getElementById('scene-container');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setClearColor(new THREE.Color(0x05070c), 1);
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      55,
      container.clientWidth / container.clientHeight,
      0.1,
      2000
    );
    camera.position.set(34, 28, 36);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.maxDistance = 1200;

    scene.add(new THREE.AmbientLight(0xa7b6ff, 0.72));
    scene.add(new THREE.HemisphereLight(0x88aaff, 0x0a0c12, 0.32));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.3);
    dirLight.position.set(40, 60, 35);
    scene.add(dirLight);

    // Background starfield
    const starGeo = new THREE.BufferGeometry();
    const starCount = 1400;
    const starPos = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
      const r = 220 * Math.pow(Math.random(), 0.45);
      const theta = Math.random() * 2 * Math.PI;
      const phi = Math.acos(2 * Math.random() - 1);
      starPos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
      starPos[i * 3 + 1] = r * Math.cos(phi);
      starPos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    const starMat = new THREE.PointsMaterial({
      size: 0.55,
      sizeAttenuation: true,
      transparent: true,
      opacity: 0.4
    });
    const stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);

    const grid = new THREE.GridHelper(120, 20, 0x1f2a3a, 0x111723);
    grid.position.y = -14;
    scene.add(grid);

    const latticeGroup = new THREE.Group();
    const solarSystemGroup = new THREE.Group();
    const galaxyGroup = new THREE.Group();
    scene.add(latticeGroup);
    scene.add(solarSystemGroup);
    scene.add(galaxyGroup);
    solarSystemGroup.visible = false;
    galaxyGroup.visible = false;

    // --------- PRU lattice data ---------
    const GRID = 16;
    const CELL_SPACING = 1.1;
    const HALF = (GRID - 1) / 2;
    const cellCount = GRID * GRID * GRID;
    document.getElementById('cell-label').textContent = cellCount.toLocaleString();

    const ua = new Float32Array(cellCount);
    const ub = new Float32Array(cellCount);
    const density = new Float32Array(cellCount);
    const curvature = new Float32Array(cellCount);
    const basePositions = new Array(cellCount);
    const dynamicPositions = new Array(cellCount);

    const cellType = new Uint8Array(cellCount);
    const galaxyIds = new Int16Array(cellCount);

    function indexFromXYZ(x, y, z) {
      return x * GRID * GRID + y * GRID + z;
    }
    function xyzFromIndex(i) {
      const gx = Math.floor(i / (GRID * GRID));
      const gy = Math.floor((i % (GRID * GRID)) / GRID);
      const gz = i % GRID;
      return { x: gx, y: gy, z: gz };
    }

    let idx = 0;
    for (let x = 0; x < GRID; x++) {
      for (let y = 0; y < GRID; y++) {
        for (let z = 0; z < GRID; z++) {
          const px = (x - HALF) * CELL_SPACING;
          const py = (y - HALF) * CELL_SPACING;
          const pz = (z - HALF) * CELL_SPACING;
          const pos = new THREE.Vector3(px, py, pz);
          basePositions[idx] = pos.clone();
          dynamicPositions[idx] = pos.clone();
          idx++;
        }
      }
    }

    // Instanced mesh for cells
    const boxGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
    const boxMat = new THREE.MeshStandardMaterial({
      color: 0x86b5ff,
      metalness: 0.08,
      roughness: 0.3,
      emissive: new THREE.Color(0x0a1835),
      emissiveIntensity: 0.45,
      transparent: true,
      opacity: 0.94,
      vertexColors: true
    });
    const instanced = new THREE.InstancedMesh(boxGeo, boxMat, cellCount);
    instanced.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    instanced.instanceColor = new THREE.InstancedBufferAttribute(
      new Float32Array(cellCount * 3),
      3
    );
    instanced.geometry.setAttribute('instanceColor', instanced.instanceColor);
    latticeGroup.add(instanced);

    // Selection highlight
    const highlight = new THREE.Mesh(
      new THREE.BoxGeometry(0.82, 0.82, 0.82),
      new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true })
    );
    highlight.visible = false;
    highlight.renderOrder = 10;
    latticeGroup.add(highlight);
    let selectedIndex = null;

    const starGeoLayer = new THREE.BufferGeometry();
    const starMatLayer = new THREE.PointsMaterial({
      size: 0.38,
      transparent: true,
      opacity: 0.95,
      vertexColors: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const starPoints = new THREE.Points(starGeoLayer, starMatLayer);
    starPoints.visible = true;
    latticeGroup.add(starPoints);

    const bhGeoLayer = new THREE.BufferGeometry();
    const bhMatLayer = new THREE.PointsMaterial({
      size: 0.32,
      transparent: true,
      opacity: 1.0,
      color: new THREE.Color(0xd1ddff),
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const bhPoints = new THREE.Points(bhGeoLayer, bhMatLayer);
    bhPoints.visible = true;
    latticeGroup.add(bhPoints);

    function updateInstanceMatrices() {
      const dummy = new THREE.Object3D();
      for (let i = 0; i < cellCount; i++) {
        const p = dynamicPositions[i];
        dummy.position.copy(p);
        dummy.rotation.y = (ua[i] + ub[i]) * Math.PI * 0.2;
        dummy.updateMatrix();
        instanced.setMatrixAt(i, dummy.matrix);
      }
      instanced.instanceMatrix.needsUpdate = true;
      if (selectedIndex !== null) {
        highlight.position.copy(dynamicPositions[selectedIndex]);
        highlight.visible = true;
      }
    }

    // --------- Gravity data (naive subset) ---------
    const particleIndices = new Set();
    while (particleIndices.size < 230) {
      particleIndices.add(Math.floor(Math.random() * cellCount));
    }
    const particleVel = new Map();
    particleIndices.forEach(i => {
      particleVel.set(
        i,
        new THREE.Vector3((Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1)
      );
    });
    console.log('PRU lattice initialized', { GRID, cellCount });
    console.log('Particle subset size', particleIndices.size);

    // --------- HUD elements ---------
    const tickLabel = document.getElementById('tick-label');
    const simtimeLabel = document.getElementById('simtime-label');
    const timescaleLabel = document.getElementById('timescale-label');
    const timescaleSlider = document.getElementById('timescale-slider');
    const densityAvgLabel = document.getElementById('density-avg');
    const densityMinMaxLabel = document.getElementById('density-minmax');
    const curvAvgLabel = document.getElementById('curv-avg');
    const energyBreakdown = document.getElementById('energy-breakdown');
    const energyDrift = document.getElementById('energy-drift');
    const agentsDiv = document.getElementById('agents');
    const presetLabel = document.getElementById('preset-label');
    const inspectorDetails = document.getElementById('inspector-details');
    const scaleButtonsDiv = document.getElementById('scale-mode-buttons');
    const solarEditorSection = document.getElementById('solar-editor');
    const solarSelect = document.getElementById('solar-body-select');
    const solarOrbitRadius = document.getElementById('solar-orbit-radius');
    const solarOrbitRadiusLabel = document.getElementById('solar-orbit-radius-label');
    const solarOrbitPeriod = document.getElementById('solar-orbit-period');
    const solarOrbitPeriodLabel = document.getElementById('solar-orbit-period-label');
    const solarRadiusSlider = document.getElementById('solar-radius');
    const solarRadiusLabel = document.getElementById('solar-radius-label');
    const solarPhysicsModeDiv = document.getElementById('solar-physics-mode');
    const galaxyToolsSection = document.getElementById('galaxy-tools');
    const galaxyInsertMode = document.getElementById('galaxy-insert-mode');
    const galaxyRadiusSlider = document.getElementById('galaxy-object-radius');
    const galaxyRadiusLabel = document.getElementById('galaxy-object-radius-label');
    const galaxyInsertBtn = document.getElementById('galaxy-insert-btn');
    solarEditorSection.style.display = 'none';
    galaxyRadiusLabel.textContent = galaxyRadiusSlider.value;
    let galaxyInsertType = 'star_system';

    const sparkCanvas = document.getElementById('sparkline');
    const sparkCtx = sparkCanvas.getContext('2d');
    const sparkHistory = [];
    function drawSparkline() {
      const w = sparkCanvas.width;
      const h = sparkCanvas.height;
      sparkCtx.clearRect(0, 0, w, h);
      sparkCtx.fillStyle = '#0c1018';
      sparkCtx.fillRect(0, 0, w, h);
      sparkCtx.strokeStyle = '#2e3b52';
      sparkCtx.lineWidth = 1;
      sparkCtx.beginPath();
      sparkCtx.moveTo(0, h - 12);
      sparkCtx.lineTo(w, h - 12);
      sparkCtx.stroke();
      if (sparkHistory.length < 2) return;
      const max = Math.max(...sparkHistory);
      const min = Math.min(...sparkHistory);
      sparkCtx.strokeStyle = '#6ad8ff';
      sparkCtx.lineWidth = 2;
      sparkCtx.beginPath();
      sparkHistory.forEach((v, i) => {
        const x = (i / (sparkHistory.length - 1)) * w;
        const norm = (v - min) / (max - min + 1e-5);
        const y = h - 4 - norm * (h - 12);
        if (i === 0) sparkCtx.moveTo(x, y);
        else sparkCtx.lineTo(x, y);
      });
      sparkCtx.stroke();
    }

    // --------- Overlay coloring ---------
    const tempColor = new THREE.Color();
    let overlayMode = 'base';

    function baseHueFromUB(val) {
      return 0.55 + 0.3 * (val - 0.5);
    }

    function applyOverlayColors() {
      for (let i = 0; i < cellCount; i++) {
        const d = density[i];
        const c = curvature[i];
        if (overlayMode === 'density') {
          const t = THREE.MathUtils.clamp(d, 0, 1);
          tempColor.setHSL(0.03 + 0.1 * t, 0.9, 0.3 + 0.35 * t);
        } else if (overlayMode === 'curvature') {
          const t = THREE.MathUtils.clamp((c + 0.5) / 1.0, 0, 1);
          tempColor.setHSL(0.6 - 0.55 * t, 0.85, 0.42 + 0.2 * Math.sin((t - 0.5) * Math.PI));
        } else {
          const hue = baseHueFromUB(ub[i]);
          const sat = 0.35 + 0.55 * ua[i];
          const light = 0.32 + 0.28 * ua[i];
          tempColor.setHSL(hue, sat, light);
        }
        instanced.setColorAt(i, tempColor);
      }
      instanced.instanceColor.needsUpdate = true;
    }

    // --------- Simulation state ---------
    let running = true;
    let tick = 0;
    let simTime = 0;
    let timeScale = 1.0;
    let accumulated = 0;
    const FIXED_DT = 0.02;

    let scaleMode = 'lattice';

    let gravityOn = false;
    let gravityMode = 'naive';
    let G = parseFloat(document.getElementById('g-slider').value);
    let damping = parseFloat(document.getElementById('damping-slider').value);
    let softening = parseFloat(document.getElementById('softening-slider').value);

    let energy0 = null;

    // --------- Field computation ---------
    const neighborOffsets = [];
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dz = -1; dz <= 1; dz++) {
          if (dx === 0 && dy === 0 && dz === 0) continue;
          neighborOffsets.push([dx, dy, dz]);
        }
      }
    }

    function computeFields() {
      let avgDensity = 0;
      let minDensity = Infinity;
      let maxDensity = -Infinity;
      let avgCurv = 0;

      for (let x = 0; x < GRID; x++) {
        for (let y = 0; y < GRID; y++) {
          for (let z = 0; z < GRID; z++) {
            const i = indexFromXYZ(x, y, z);
            density[i] = ua[i];
            let sum = 0;
            let count = 0;
            for (const [dx, dy, dz] of neighborOffsets) {
              const nx = x + dx;
              const ny = y + dy;
              const nz = z + dz;
              if (nx < 0 || ny < 0 || nz < 0 || nx >= GRID || ny >= GRID || nz >= GRID) continue;
              const ni = indexFromXYZ(nx, ny, nz);
              sum += ub[ni];
              count++;
            }
            const neighborAvg = count > 0 ? sum / count : ub[i];
            curvature[i] = ub[i] - neighborAvg;

            const d = density[i];
            avgDensity += d;
            minDensity = Math.min(minDensity, d);
            maxDensity = Math.max(maxDensity, d);
            avgCurv += curvature[i];
          }
        }
      }

      avgDensity /= cellCount;
      avgCurv /= cellCount;

      densityAvgLabel.textContent = avgDensity.toFixed(3);
      densityMinMaxLabel.textContent = `${minDensity.toFixed(3)} / ${maxDensity.toFixed(3)}`;
      curvAvgLabel.textContent = avgCurv.toFixed(4);

      sparkHistory.push(avgDensity);
      if (sparkHistory.length > 80) sparkHistory.shift();
      drawSparkline();
    }

    // --------- Gravity ---------
    function applyNaiveGravity() {
      const ids = [...particleIndices];
      const forces = ids.map(() => new THREE.Vector3());
      let kinetic = 0;
      let potential = 0;
      for (let a = 0; a < ids.length; a++) {
        for (let b = a + 1; b < ids.length; b++) {
          const ia = ids[a];
          const ib = ids[b];
          const pa = dynamicPositions[ia];
          const pb = dynamicPositions[ib];
          const delta = new THREE.Vector3().subVectors(pb, pa);
          const distSq = Math.max(delta.lengthSq(), softening * softening);
          const invDist = 1 / Math.sqrt(distSq);
          const forceMag = (G * ua[ia] * ua[ib]) / distSq;
          const dir = delta.multiplyScalar(invDist);
          const f = dir.clone().multiplyScalar(forceMag);
          forces[a].add(f);
          forces[b].sub(f);
          potential -= G * ua[ia] * ua[ib] * invDist;
        }
      }
      for (let k = 0; k < ids.length; k++) {
        const i = ids[k];
        const vel = particleVel.get(i) || new THREE.Vector3();
        vel.add(forces[k].multiplyScalar(FIXED_DT));
        vel.multiplyScalar(1 - damping);
        particleVel.set(i, vel);
        dynamicPositions[i].add(vel.clone().multiplyScalar(FIXED_DT));
        kinetic += 0.5 * vel.lengthSq();
      }
      return { kinetic, potential };
    }

    const relationalVel = Array.from({ length: cellCount }, () => new THREE.Vector3());
    function applyRelationalGravity() {
      let kinetic = 0;
      let potential = 0;
      const grad = new THREE.Vector3();

      for (let x = 1; x < GRID - 1; x++) {
        for (let y = 1; y < GRID - 1; y++) {
          for (let z = 1; z < GRID - 1; z++) {
            const i = indexFromXYZ(x, y, z);
            const gradX = density[indexFromXYZ(x + 1, y, z)] - density[indexFromXYZ(x - 1, y, z)];
            const gradY = density[indexFromXYZ(x, y + 1, z)] - density[indexFromXYZ(x, y - 1, z)];
            const gradZ = density[indexFromXYZ(x, y, z + 1)] - density[indexFromXYZ(x, y, z - 1)];
            grad.set(gradX, gradY, gradZ).multiplyScalar(G * 0.25);

            const vel = relationalVel[i];
            vel.addScaledVector(grad, FIXED_DT);
            vel.multiplyScalar(1 - Math.min(0.9, damping * 0.8));

            dynamicPositions[i].addScaledVector(vel, FIXED_DT);
            dynamicPositions[i].lerp(basePositions[i], 0.12 * FIXED_DT);

            kinetic += 0.5 * vel.lengthSq();
            potential -= grad.lengthSq() * 0.05;
          }
        }
      }
      return { kinetic, potential };
    }

    // --------- Agents ---------
    let galaxyCounter = 0;
    const lensingScale = 1.35;

    function updateStellarLayers() {
      const starPositions = [];
      const starColors = [];
      const bhPositions = [];
      const color = new THREE.Color();

      for (let i = 0; i < cellCount; i++) {
        if (cellType[i] === 1) {
          const p = dynamicPositions[i];
          starPositions.push(p.x, p.y, p.z);
          const tint = THREE.MathUtils.clamp((density[i] - 0.7) / 0.4, 0, 1);
          color.setHSL(0.1 + 0.25 * (1 - tint), 0.8, 0.65 + 0.1 * tint);
          starColors.push(color.r, color.g, color.b);
        } else if (cellType[i] === 2) {
          const p = dynamicPositions[i];
          bhPositions.push(p.x, p.y, p.z);
        }
      }

      starGeoLayer.setAttribute(
        'position',
        new THREE.BufferAttribute(new Float32Array(starPositions), 3)
      );
      starGeoLayer.setAttribute(
        'color',
        new THREE.BufferAttribute(new Float32Array(starColors), 3)
      );
      starGeoLayer.computeBoundingSphere();

      const haloPositions = new Float32Array(bhPositions.length * 3);
      for (let i = 0; i < bhPositions.length; i += 3) {
        haloPositions[i] = bhPositions[i] * lensingScale;
        haloPositions[i + 1] = bhPositions[i + 1] * lensingScale;
        haloPositions[i + 2] = bhPositions[i + 2] * lensingScale;
      }

      bhGeoLayer.setAttribute(
        'position',
        new THREE.BufferAttribute(new Float32Array(bhPositions), 3)
      );
      bhGeoLayer.computeBoundingSphere();
      bhMatLayer.size = 0.34 + Math.min(0.12, bhPositions.length * 0.0002);

      const auraGeometry = new THREE.BufferGeometry();
      auraGeometry.setAttribute('position', new THREE.BufferAttribute(haloPositions, 3));
      const auraPoints = new THREE.Points(
        auraGeometry,
        new THREE.PointsMaterial({
          size: 0.55,
          transparent: true,
          opacity: 0.22,
          color: 0x9fc4ff,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        })
      );
      auraPoints.renderOrder = 0.5;
      if (bhPoints.children.length) {
        const child = bhPoints.children[0];
        child.geometry?.dispose();
        child.material?.dispose();
        bhPoints.remove(child);
      }
      bhPoints.add(auraPoints);
    }

    function updateAgents() {
      cellType.fill(0);
      galaxyIds.fill(-1);
      const starThreshold = 0.82;
      const bhDensityThreshold = 0.9;
      const bhCurvThreshold = 0.12;

      const bins = new Map();
      for (let i = 0; i < cellCount; i++) {
        const d = density[i];
        const k = curvature[i];
        if (d > bhDensityThreshold && k > bhCurvThreshold) {
          cellType[i] = 2;
        } else if (d > starThreshold) {
          cellType[i] = 1;
        }
        if (cellType[i] > 0) {
          const p = basePositions[i];
          const key = `${Math.round(p.x / 6)},${Math.round(p.y / 6)},${Math.round(p.z / 6)}`;
          if (!bins.has(key)) bins.set(key, []);
          bins.get(key).push(i);
        }
      }

      let html = '';
      let gid = 1;
      bins.forEach(indices => {
        if (indices.length >= 8) {
          let stars = 0;
          let bh = 0;
          let mass = 0;
          indices.forEach(i => {
            if (cellType[i] === 1) stars++;
            if (cellType[i] === 2) bh++;
            mass += ua[i];
            galaxyIds[i] = gid;
          });
          const massDelta = ((mass / indices.length - 0.5) * 100).toFixed(1);
          html += `Agent G-${gid}: ${stars} stars, ${bh} BH cores, mass ${massDelta}%<br>`;
          gid++;
        }
      });
      galaxyCounter = gid - 1;
      if (!html) {
        html = '<span class="text-muted">No active clusters. Halos stabilizing...</span>';
      }
      agentsDiv.innerHTML = html;
      updateStellarLayers();
    }

    // --------- Scale layers: solar system & galaxy ---------
    const solarBodies = [
      { id: 'sun', type: 'star', radius: 2.0, color: 0xfff6c7, position: new THREE.Vector3(0, 0, 0), mass: 2400 },
      { id: 'mercury', type: 'planet', orbitRadius: 7, orbitPeriod: 8, eccentricity: 0.03, inclination: 0.01, radius: 0.3, color: 0xd6d5d2, phaseOffset: 0.2, mass: 0.33 },
      { id: 'venus', type: 'planet', orbitRadius: 9.5, orbitPeriod: 13, eccentricity: 0.02, inclination: 0.015, radius: 0.45, color: 0xf5c07a, phaseOffset: 1.6, mass: 4.8 },
      { id: 'earth', type: 'planet', orbitRadius: 12, orbitPeriod: 20, eccentricity: 0.05, inclination: 0.02, radius: 0.6, color: 0x7fb8ff, phaseOffset: 0.0, mass: 6.0 },
      { id: 'mars', type: 'planet', orbitRadius: 15, orbitPeriod: 28, eccentricity: 0.06, inclination: 0.018, radius: 0.45, color: 0xff876c, phaseOffset: 2.1, mass: 0.64 },
      { id: 'jupiter', type: 'planet', orbitRadius: 21, orbitPeriod: 60, eccentricity: 0.03, inclination: 0.022, radius: 1.2, color: 0xf0d4a6, phaseOffset: 1.1, mass: 1900 },
      { id: 'saturn', type: 'planet', orbitRadius: 27, orbitPeriod: 85, eccentricity: 0.04, inclination: 0.028, radius: 1.0, color: 0xf3e2c1, phaseOffset: 0.6, mass: 568 },
      { id: 'neptune', type: 'planet', orbitRadius: 34, orbitPeriod: 115, eccentricity: 0.02, inclination: 0.03, radius: 0.9, color: 0x7ac8f7, phaseOffset: 2.4, mass: 102 }
    ];

    const solarMeshes = new Map();
    const solarTrails = new Map();
    const solarRings = new Map();
    const TRAIL_SEGMENTS = 120;
    let sunLight = null;
    const solarState = new Map();
    let solarPhysicsMode = 'analytic';
    let solarLastTime = 0;
    const solarG = 0.08;

    function createTrail(initial) {
      const trailGeo = new THREE.BufferGeometry();
      const arr = new Float32Array((TRAIL_SEGMENTS + 1) * 3);
      for (let i = 0; i <= TRAIL_SEGMENTS; i++) {
        arr[i * 3] = initial.x;
        arr[i * 3 + 1] = initial.y;
        arr[i * 3 + 2] = initial.z;
      }
      trailGeo.setAttribute('position', new THREE.BufferAttribute(arr, 3));
      const trail = new THREE.Line(
        trailGeo,
        new THREE.LineBasicMaterial({ color: 0x7fb8ff, transparent: true, opacity: 0.4 })
      );
      trail.frustumCulled = false;
      return trail;
    }

    function getStarMass() {
      const star = solarBodies.find(b => b.type === 'star');
      return star?.mass || 1200;
    }

    function keplerPeriodForRadius(r) {
      const m = getStarMass();
      return THREE.MathUtils.clamp(Math.sqrt((r * r * r) / m) * 750 + 6, 5, 120);
    }

    function ensureSolarState(body) {
      if (solarState.has(body.id)) return solarState.get(body.id);
      const position = new THREE.Vector3(body.orbitRadius, 0, 0);
      const starMass = getStarMass();
      const speed = Math.sqrt((solarG * starMass) / Math.max(0.2, body.orbitRadius));
      const velocity = new THREE.Vector3(0, 0, speed);
      const state = { position, velocity };
      solarState.set(body.id, state);
      return state;
    }

    function resetBodyOrbit(body) {
      const state = ensureSolarState(body);
      state.position.set(body.orbitRadius, 0, 0);
      const starMass = getStarMass();
      const speed = Math.sqrt((solarG * starMass) / Math.max(0.2, body.orbitRadius));
      state.velocity.set(0, 0, speed);
    }

    function initSolarSystem() {
      solarBodies.forEach(body => {
        if (body.type === 'star') {
          const geo = new THREE.SphereGeometry(body.radius, 28, 28);
          const mat = new THREE.MeshStandardMaterial({
            color: body.color,
            emissive: new THREE.Color(0xfff3c0),
            emissiveIntensity: 1.8,
            roughness: 0.25
          });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.userData.baseRadius = body.radius;
          solarMeshes.set(body.id, mesh);
          solarSystemGroup.add(mesh);
          sunLight = new THREE.PointLight(0xfff1c4, 1.4, 180);
          mesh.add(sunLight);
          return;
        }

        const geo = new THREE.SphereGeometry(body.radius, 24, 24);
        const mat = new THREE.MeshStandardMaterial({ color: body.color, roughness: 0.45, metalness: 0.05 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.userData.baseRadius = body.radius;
        solarMeshes.set(body.id, mesh);
        solarSystemGroup.add(mesh);

        const ringGeo = new THREE.RingGeometry(body.orbitRadius - 0.05, body.orbitRadius + 0.05, 64);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x2f425b, side: THREE.DoubleSide, transparent: true, opacity: 0.35 });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = -Math.PI / 2 + body.inclination;
        solarRings.set(body.id, ring);
        solarSystemGroup.add(ring);

        const initialPos = new THREE.Vector3(body.orbitRadius, 0, 0);
        const trail = createTrail(initialPos);
        solarTrails.set(body.id, trail);
        solarSystemGroup.add(trail);

        ensureSolarState(body);
      });
    }

    function analyticPosition(body, time) {
      const omega = (2 * Math.PI) / body.orbitPeriod;
      const angle = omega * time + body.phaseOffset;
      const r = body.orbitRadius * (1 - body.eccentricity * Math.cos(angle));
      const x = r * Math.cos(angle);
      const z = r * Math.sin(angle);
      const y = Math.sin(body.inclination) * r * 0.15;
      return { pos: new THREE.Vector3(x, y, z), angle };
    }

    function seedNBodyFromAnalytic(time) {
      solarBodies.forEach(body => {
        if (body.type === 'star') {
          ensureSolarState(body);
          return;
        }
        const { pos, angle } = analyticPosition(body, time);
        const state = ensureSolarState(body);
        state.position.copy(pos);
        const starMass = getStarMass();
        const tangential = Math.sqrt((solarG * starMass) / Math.max(0.2, body.orbitRadius));
        state.velocity.set(-Math.sin(angle) * tangential, 0, Math.cos(angle) * tangential);
      });
    }

    function updateSolarSystem(time) {
      if (solarPhysicsMode === 'analytic') {
        solarBodies.forEach(body => {
          if (body.type === 'star') return;
          const { pos } = analyticPosition(body, time);
          const mesh = solarMeshes.get(body.id);
          if (mesh) mesh.position.copy(pos);
          const ring = solarRings.get(body.id);
          if (ring) {
            ring.rotation.x = -Math.PI / 2 + body.inclination;
            ring.geometry.computeBoundingSphere();
          }
          const trail = solarTrails.get(body.id);
          if (trail) {
            const arr = trail.geometry.attributes.position.array;
            arr.copyWithin(0, 3);
            arr[arr.length - 3] = pos.x;
            arr[arr.length - 2] = pos.y;
            arr[arr.length - 1] = pos.z;
            trail.geometry.attributes.position.needsUpdate = true;
          }
        });
        solarLastTime = time;
        return;
      }

      const delta = Math.min(0.08, Math.max(0.001, time - solarLastTime));
      solarLastTime = time;
      let remaining = delta;
      while (remaining > 1e-4) {
        const dt = Math.min(FIXED_DT, remaining);
        remaining -= dt;

        const accMap = new Map();
        solarBodies.forEach(body => {
          accMap.set(body.id, new THREE.Vector3());
          ensureSolarState(body);
        });

        for (let a = 0; a < solarBodies.length; a++) {
          for (let b = a + 1; b < solarBodies.length; b++) {
            const bodyA = solarBodies[a];
            const bodyB = solarBodies[b];
            const stateA = ensureSolarState(bodyA);
            const stateB = ensureSolarState(bodyB);
            const deltaVec = new THREE.Vector3().subVectors(stateB.position, stateA.position);
            const distSq = Math.max(deltaVec.lengthSq(), 0.4);
            const invDist = 1 / Math.sqrt(distSq);
            const dir = deltaVec.clone().multiplyScalar(invDist);
            const forceMag = (solarG * (bodyA.mass || 1) * (bodyB.mass || 1)) / distSq;
            const accA = accMap.get(bodyA.id);
            const accB = accMap.get(bodyB.id);
            accA.addScaledVector(dir, forceMag / Math.max(1, bodyA.mass || 1));
            accB.addScaledVector(dir, -forceMag / Math.max(1, bodyB.mass || 1));
          }
        }

        solarBodies.forEach(body => {
          const state = ensureSolarState(body);
          const acc = accMap.get(body.id) || new THREE.Vector3();
          if (body.type !== 'star') {
            state.velocity.addScaledVector(acc, dt);
            state.velocity.multiplyScalar(1 - 0.01 * dt);
            state.position.addScaledVector(state.velocity, dt);
          } else {
            state.position.set(0, 0, 0);
            state.velocity.set(0, 0, 0);
          }
        });
      }

      solarBodies.forEach(body => {
        if (body.type === 'star') return;
        const state = ensureSolarState(body);
        const mesh = solarMeshes.get(body.id);
        if (mesh) mesh.position.copy(state.position);
        const trail = solarTrails.get(body.id);
        if (trail) {
          const arr = trail.geometry.attributes.position.array;
          arr.copyWithin(0, 3);
          arr[arr.length - 3] = state.position.x;
          arr[arr.length - 2] = state.position.y;
          arr[arr.length - 1] = state.position.z;
          trail.geometry.attributes.position.needsUpdate = true;
        }
      });
    }

    function refreshSolarGeometry(body) {
      const mesh = solarMeshes.get(body.id);
      if (mesh) {
        mesh.scale.setScalar(body.radius / (mesh.userData.baseRadius || body.radius));
      }
      if (solarPhysicsMode === 'nbody' && body.type === 'planet') {
        resetBodyOrbit(body);
      }
      const ring = solarRings.get(body.id);
      if (ring) {
        ring.geometry.dispose();
        ring.geometry = new THREE.RingGeometry(body.orbitRadius - 0.05, body.orbitRadius + 0.05, 64);
        ring.rotation.x = -Math.PI / 2 + body.inclination;
      }
      const trail = solarTrails.get(body.id);
      if (trail) {
        const arr = trail.geometry.attributes.position.array;
        for (let i = 0; i <= TRAIL_SEGMENTS; i++) {
          const idx = i * 3;
          arr[idx] = body.orbitRadius;
          arr[idx + 1] = 0;
          arr[idx + 2] = 0;
        }
        trail.geometry.attributes.position.needsUpdate = true;
      }
    }

    const galaxyParams = { numStars: 5600, numArms: 4, armTightness: 1.6, armScatter: 0.5, radialScale: 150 };
    let galaxyPoints = null;
    let galaxyBasePositions = null;
    const galaxyObjects = [];
    let galaxyRotation = 0;
    const galaxySun = new THREE.Mesh(
      new THREE.SphereGeometry(1.2, 22, 22),
      new THREE.MeshStandardMaterial({ color: 0xffe0a3, emissive: 0xffd27f, emissiveIntensity: 1.1 })
    );
    const galacticOrbitRadius = 90;
    const galacticOrbitPeriod = 260;
    const galaxyOrbitPath = new THREE.Line(
      new THREE.BufferGeometry().setFromPoints(
        Array.from({ length: 120 }, (_, i) => {
          const ang = (i / 120) * Math.PI * 2;
          return new THREE.Vector3(Math.cos(ang) * galacticOrbitRadius, 0, Math.sin(ang) * galacticOrbitRadius);
        })
      ),
      new THREE.LineBasicMaterial({ color: 0x38506e, transparent: true, opacity: 0.35 })
    );
    galaxyOrbitPath.rotation.x = 0;

    function initGalaxy() {
      const positions = new Float32Array(galaxyParams.numStars * 3);
      const colors = new Float32Array(galaxyParams.numStars * 3);
      const color = new THREE.Color();

      for (let i = 0; i < galaxyParams.numStars; i++) {
        const arm = Math.floor(Math.random() * galaxyParams.numArms);
        const armAngle = (arm / galaxyParams.numArms) * 2 * Math.PI;
        const radius = galaxyParams.radialScale * Math.pow(Math.random(), 0.6);
        const theta = armAngle + radius * galaxyParams.armTightness + (Math.random() - 0.5) * galaxyParams.armScatter;
        const height = THREE.MathUtils.randFloatSpread(2.4);
        const idx = i * 3;
        const x = Math.cos(theta) * radius + Math.random() * 3;
        const z = Math.sin(theta) * radius + Math.random() * 3;
        positions[idx] = x;
        positions[idx + 1] = height;
        positions[idx + 2] = z;

        const hue = 0.55 + Math.random() * 0.12;
        const sat = 0.55 + Math.random() * 0.25;
        const light = 0.45 + Math.random() * 0.35;
        color.setHSL(hue, sat, light);
        colors[idx] = color.r;
        colors[idx + 1] = color.g;
        colors[idx + 2] = color.b;
      }

      galaxyBasePositions = positions.slice();
      const galaxyGeo = new THREE.BufferGeometry();
      galaxyGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      galaxyGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      const galaxyMat = new THREE.PointsMaterial({
        size: 0.9,
        sizeAttenuation: true,
        vertexColors: true,
        transparent: true,
        opacity: 0.88,
        depthWrite: false
      });
      galaxyPoints = new THREE.Points(galaxyGeo, galaxyMat);
      galaxyPoints.rotation.x = 0;
      galaxyGroup.add(galaxyPoints);
      galaxyGroup.add(galaxySun);
      galaxyGroup.add(galaxyOrbitPath);
    }

    function addGalaxyObject(type, radius) {
      const geo = new THREE.SphereGeometry(type === 'black_hole' ? 1.4 : 1.0, 16, 16);
      const mat = new THREE.MeshStandardMaterial({
        color: type === 'black_hole' ? 0xa6c8ff : 0x7cffd3,
        emissive: type === 'black_hole' ? new THREE.Color(0x7fb8ff) : new THREE.Color(0x0f2f3a),
        emissiveIntensity: type === 'black_hole' ? 1.4 : 0.6,
        roughness: 0.25
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(radius, 0, 0);
      galaxyGroup.add(mesh);
      galaxyObjects.push({ type, radius, mesh, angle: Math.random() * Math.PI * 2 });
    }

    function updateGalaxy(time) {
      if (!galaxySun || !galaxyPoints || !galaxyBasePositions) return;
      const omega = (2 * Math.PI) / galacticOrbitPeriod;
      const angle = omega * time;
      galaxySun.position.set(Math.cos(angle) * galacticOrbitRadius, Math.sin(angle * 0.5) * 0.6, Math.sin(angle) * galacticOrbitRadius);
      galaxySun.rotation.y += 0.0045;

      galaxyRotation = 0.0015 * time;
      const cosR = Math.cos(galaxyRotation);
      const sinR = Math.sin(galaxyRotation);
      const arr = galaxyPoints.geometry.attributes.position.array;

      for (let i = 0; i < galaxyParams.numStars; i++) {
        const idx = i * 3;
        let x = galaxyBasePositions[idx];
        let y = galaxyBasePositions[idx + 1] * 0.7;
        let z = galaxyBasePositions[idx + 2];
        const rx = x * cosR - z * sinR;
        const rz = x * sinR + z * cosR;
        x = rx;
        z = rz;

        for (const obj of galaxyObjects) {
          if (obj.type !== 'black_hole') continue;
          const dx = x - obj.mesh.position.x;
          const dz = z - obj.mesh.position.z;
          const dist = Math.sqrt(dx * dx + dz * dz);
          const influence = 55;
          if (dist < influence) {
            const pull = (1 - dist / influence) * 3.2;
            x -= (dx / (dist + 0.001)) * pull;
            z -= (dz / (dist + 0.001)) * pull;
            y *= 0.98;
          }
        }

        arr[idx] = x;
        arr[idx + 1] = y;
        arr[idx + 2] = z;
      }
      galaxyPoints.geometry.attributes.position.needsUpdate = true;
      galaxyPoints.geometry.computeBoundingSphere();

      galaxyObjects.forEach(obj => {
        obj.angle += 0.0025 * timeScale;
        const y = obj.type === 'black_hole' ? 0.1 : Math.sin(obj.angle * 0.5) * 0.6;
        obj.mesh.position.set(Math.cos(obj.angle) * obj.radius, y, Math.sin(obj.angle) * obj.radius);
      });
    }

    function focusOnVector(targetVec, distance, elevationAngleRad = 0.4) {
      const dir = new THREE.Vector3(0, Math.sin(elevationAngleRad), 1).normalize();
      const camPos = targetVec.clone().addScaledVector(dir, distance);
      camera.position.copy(camPos);
      controls.target.copy(targetVec);
      controls.update();
    }

    function focusOnSun() {
      const sun = solarMeshes.get('sun');
      if (sun) focusOnVector(sun.position, 55, 0.45);
    }

    function focusOnPlanet(id) {
      const mesh = solarMeshes.get(id);
      const body = solarBodies.find(b => b.id === id);
      if (mesh && body) {
        focusOnVector(mesh.position, Math.max(18, body.orbitRadius * 1.4), 0.35);
      }
    }

    function focusOnGalaxy() {
      focusOnVector(new THREE.Vector3(0, 0, 0), 260, 0.55);
    }

    function setScaleMode(mode) {
      scaleMode = mode;
      [...scaleButtonsDiv.children].forEach(btn => btn.classList.toggle('active', btn.dataset.scale === mode));
      latticeGroup.visible = mode === 'lattice';
      solarSystemGroup.visible = mode === 'solar_system';
      galaxyGroup.visible = mode === 'galaxy';
      grid.visible = mode === 'lattice';
      starPoints.visible = bhPoints.visible = mode === 'lattice';
      highlight.visible = mode === 'lattice' && selectedIndex !== null;
      solarEditorSection.style.display = mode === 'solar_system' ? 'block' : 'none';
      galaxyToolsSection.style.display = mode === 'galaxy' ? 'block' : 'none';
      if (mode === 'solar_system') {
        focusOnSun();
      } else if (mode === 'galaxy') {
        focusOnGalaxy();
      } else {
        focusOnVector(new THREE.Vector3(0, 0, 0), 70, 0.5);
      }
    }

    scaleButtonsDiv.addEventListener('click', e => {
      if (e.target.tagName !== 'BUTTON') return;
      setScaleMode(e.target.dataset.scale);
    });

    function syncSolarEditor(id) {
      const body = solarBodies.find(b => b.id === id);
      if (!body) return;
      solarSelect.value = id;
      solarOrbitRadius.value = body.orbitRadius;
      solarOrbitRadiusLabel.textContent = `${body.orbitRadius.toFixed(1)} PRU`;
      solarOrbitPeriod.value = body.orbitPeriod;
      solarOrbitPeriodLabel.textContent = `${body.orbitPeriod.toFixed(0)} s`;
      solarRadiusSlider.value = body.radius;
      solarRadiusLabel.textContent = `${body.radius.toFixed(2)} u`;
    }

    function populateSolarEditor() {
      solarSelect.innerHTML = '';
      solarBodies
        .filter(b => b.type === 'planet')
        .forEach(body => {
          const opt = document.createElement('option');
          opt.value = body.id;
          opt.textContent = body.id.replace('_', ' ').replace(/\b\w/g, c => c.toUpperCase());
          solarSelect.appendChild(opt);
        });
      const first = solarSelect.options[0]?.value;
      if (first) syncSolarEditor(first);
    }

    solarSelect.addEventListener('change', e => {
      syncSolarEditor(e.target.value);
      focusOnPlanet(e.target.value);
    });

    solarPhysicsModeDiv.addEventListener('click', e => {
      if (e.target.tagName !== 'BUTTON') return;
      solarPhysicsMode = e.target.dataset.mode;
      [...solarPhysicsModeDiv.children].forEach(btn => btn.classList.toggle('active', btn === e.target));
      if (solarPhysicsMode === 'nbody') {
        seedNBodyFromAnalytic(simTime);
      }
      solarLastTime = simTime;
    });

    solarOrbitRadius.addEventListener('input', () => {
      const body = solarBodies.find(b => b.id === solarSelect.value);
      if (!body) return;
      body.orbitRadius = parseFloat(solarOrbitRadius.value);
      solarOrbitRadiusLabel.textContent = `${body.orbitRadius.toFixed(1)} PRU`;
      if (solarPhysicsMode === 'analytic') {
        body.orbitPeriod = keplerPeriodForRadius(body.orbitRadius);
        solarOrbitPeriod.value = body.orbitPeriod;
        solarOrbitPeriodLabel.textContent = `${body.orbitPeriod.toFixed(0)} s`;
      }
      if (solarPhysicsMode === 'nbody') resetBodyOrbit(body);
      refreshSolarGeometry(body);
    });

    solarOrbitPeriod.addEventListener('input', () => {
      const body = solarBodies.find(b => b.id === solarSelect.value);
      if (!body) return;
      body.orbitPeriod = parseFloat(solarOrbitPeriod.value);
      solarOrbitPeriodLabel.textContent = `${body.orbitPeriod.toFixed(0)} s`;
    });

    solarRadiusSlider.addEventListener('input', () => {
      const body = solarBodies.find(b => b.id === solarSelect.value);
      if (!body) return;
      body.radius = parseFloat(solarRadiusSlider.value);
      solarRadiusLabel.textContent = `${body.radius.toFixed(2)} u`;
      refreshSolarGeometry(body);
    });

    galaxyInsertMode.addEventListener('click', e => {
      if (e.target.tagName !== 'BUTTON') return;
      galaxyInsertType = e.target.dataset.object;
      [...galaxyInsertMode.children].forEach(btn => btn.classList.toggle('active', btn === e.target));
    });
    galaxyRadiusSlider.addEventListener('input', () => {
      galaxyRadiusLabel.textContent = galaxyRadiusSlider.value;
    });
    galaxyInsertBtn.addEventListener('click', () => {
      if (scaleMode !== 'galaxy') return;
      addGalaxyObject(galaxyInsertType, parseFloat(galaxyRadiusSlider.value));
    });

    // --------- Inspector ---------
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    function updateInspector(i) {
      if (i === null || i === undefined) {
        inspectorDetails.textContent = 'No cell selected.';
        return;
      }
      const { x, y, z } = xyzFromIndex(i);
      const pos = dynamicPositions[i];
      const uaVal = ua[i];
      const ubVal = ub[i];
      const d = density[i];
      const k = curvature[i];
      const type = cellType[i] === 2 ? 'Black-hole seed' : cellType[i] === 1 ? 'Star cell' : 'Gas / background cell';
      const galaxy = galaxyIds[i] > 0 ? `G-${galaxyIds[i]}` : 'None';
      inspectorDetails.textContent = `Index ${i} ( ${x}, ${y}, ${z} )
World: (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})
UA ${uaVal.toFixed(3)} · UB ${ubVal.toFixed(3)}
Density ${d.toFixed(4)} · Curvature ${k.toFixed(4)}
Class: ${type}
Galaxy: ${galaxy}`;
      selectedIndex = i;
      highlight.visible = true;
      highlight.position.copy(pos);
    }

    function onPointerDown(event) {
      if (event.button !== 0 || scaleMode !== 'lattice') return;
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObject(instanced);
      if (intersects.length > 0 && intersects[0].instanceId !== undefined) {
        updateInspector(intersects[0].instanceId);
      }
    }
    renderer.domElement.addEventListener('pointerdown', onPointerDown);

    // --------- Presets ---------
    const presetButtonsDiv = document.getElementById('preset-buttons');

    function resetSimState() {
      tick = 0;
      simTime = 0;
      accumulated = 0;
      energy0 = null;
      sparkHistory.length = 0;
      drawSparkline();
      tickLabel.textContent = '0';
      simtimeLabel.textContent = '0.00s';
      energyBreakdown.textContent = '0';
      energyDrift.textContent = '0';
    }

    function applyPreset(name) {
      for (let i = 0; i < cellCount; i++) {
        const p = basePositions[i];
        const r = p.length() / (HALF * CELL_SPACING * 1.25);
        const noise = Math.random() * 0.08;
        if (name === 'cluster') {
          const core = Math.exp(-r * r * 2.2);
          ua[i] = THREE.MathUtils.clamp(core + noise, 0, 1);
          ub[i] = THREE.MathUtils.clamp(0.55 + (0.6 - r) * 0.6 + (Math.random() - 0.5) * 0.12, 0, 1);
        } else if (name === 'filaments') {
          const axis = Math.min(Math.abs(p.x), Math.abs(p.z));
          const spine = Math.exp(-(axis * axis) / 35);
          const layer = Math.exp(-(Math.abs(p.y) * Math.abs(p.y)) / 28);
          ua[i] = THREE.MathUtils.clamp(spine * layer + noise * 0.9, 0, 1);
          ub[i] = THREE.MathUtils.clamp(0.4 + (p.y / (HALF * CELL_SPACING)) * 0.35 + (Math.random() - 0.5) * 0.18, 0, 1);
        } else if (name === 'shells') {
          const r0 = 0.6;
          const shell = Math.exp(-((r - r0) * (r - r0)) * 18);
          ua[i] = THREE.MathUtils.clamp(shell + noise * 0.8, 0, 1);
          ub[i] = THREE.MathUtils.clamp(r * 0.9 + (Math.random() - 0.5) * 0.15, 0, 1);
        } else {
          ua[i] = Math.random();
          ub[i] = Math.random();
        }
        dynamicPositions[i].copy(basePositions[i]);
      }
      particleVel.forEach(v => v.set(0, 0, 0));
      relationalVel.forEach(v => v.set(0, 0, 0));
      resetSimState();
      computeFields();
      updateInstanceMatrices();
      applyOverlayColors();
      updateAgents();

      presetLabel.textContent =
        name === 'cluster'
          ? 'Central Cluster'
          : name === 'filaments'
          ? 'Cosmic Web'
          : name === 'shells'
          ? 'Voids & Shells'
          : 'Random Gas';
      [...presetButtonsDiv.children].forEach(btn => btn.classList.toggle('active', btn.dataset.preset === name));
    }

    presetButtonsDiv.addEventListener('click', e => {
      if (e.target.tagName !== 'BUTTON') return;
      const preset = e.target.dataset.preset;
      applyPreset(preset);
    });

    // --------- UI wiring ---------
    const pauseBtn = document.getElementById('pause-btn');
    const stepBtn = document.getElementById('step-btn');
    const slowerBtn = document.getElementById('slower-btn');
    const fasterBtn = document.getElementById('faster-btn');

    pauseBtn.addEventListener('click', () => {
      running = !running;
      pauseBtn.textContent = running ? 'Pause' : 'Resume';
    });
    stepBtn.addEventListener('click', () => {
      if (!running) performTick();
    });
    slowerBtn.addEventListener('click', () => {
      timeScale = Math.max(0.05, timeScale / 1.5);
      timescaleSlider.value = timeScale.toFixed(2);
      timescaleLabel.textContent = `${timeScale.toFixed(2)}×`;
    });
    fasterBtn.addEventListener('click', () => {
      timeScale = Math.min(8, timeScale * 1.5);
      timescaleSlider.value = timeScale.toFixed(2);
      timescaleLabel.textContent = `${timeScale.toFixed(2)}×`;
    });
    timescaleSlider.addEventListener('input', () => {
      timeScale = parseFloat(timescaleSlider.value);
      timescaleLabel.textContent = `${timeScale.toFixed(2)}×`;
    });

    document.getElementById('overlay-buttons').addEventListener('click', e => {
      if (e.target.tagName !== 'BUTTON') return;
      overlayMode = e.target.dataset.mode;
      [...e.currentTarget.children].forEach(btn => btn.classList.toggle('active', btn === e.target));
      applyOverlayColors();
    });

    document.getElementById('gravity-toggle').addEventListener('click', e => {
      gravityOn = !gravityOn;
      e.target.textContent = gravityOn ? 'Gravity: ON' : 'Gravity: OFF';
      if (gravityOn && energy0 === null) energy0 = 0.0001;
    });
    document.getElementById('gravity-mode').addEventListener('click', e => {
      if (e.target.tagName !== 'BUTTON') return;
      gravityMode = e.target.dataset.mode;
      [...e.currentTarget.children].forEach(btn => btn.classList.toggle('active', btn === e.target));
    });
    const gSlider = document.getElementById('g-slider');
    const dampingSlider = document.getElementById('damping-slider');
    const softeningSlider = document.getElementById('softening-slider');
    const gLabel = document.getElementById('g-label');
    const dampingLabel = document.getElementById('damping-label');
    const softeningLabel = document.getElementById('softening-label');

    gSlider.addEventListener('input', () => {
      G = parseFloat(gSlider.value);
      gLabel.textContent = G.toFixed(2);
    });
    dampingSlider.addEventListener('input', () => {
      damping = parseFloat(dampingSlider.value);
      dampingLabel.textContent = damping.toFixed(3);
    });
    softeningSlider.addEventListener('input', () => {
      softening = parseFloat(softeningSlider.value);
      softeningLabel.textContent = softening.toFixed(1);
    });

    // Keyboard shortcuts
    window.addEventListener('keydown', e => {
      if (e.code === 'Space') {
        e.preventDefault();
        pauseBtn.click();
      } else if (e.key === '.') {
        if (!running) performTick();
      } else if (e.key === '-' || e.key === '_') {
        slowerBtn.click();
      } else if (e.key === '+' || e.key === '=') {
        fasterBtn.click();
      } else if (e.key.toLowerCase() === 'd') {
        overlayMode = 'density';
        document.querySelectorAll('#overlay-buttons button').forEach(btn =>
          btn.classList.toggle('active', btn.dataset.mode === 'density')
        );
        applyOverlayColors();
      } else if (e.key.toLowerCase() === 'c') {
        overlayMode = 'curvature';
        document.querySelectorAll('#overlay-buttons button').forEach(btn =>
          btn.classList.toggle('active', btn.dataset.mode === 'curvature')
        );
        applyOverlayColors();
      } else if (e.key.toLowerCase() === 'g') {
        document.getElementById('gravity-toggle').click();
      }
    });

    // --------- Simulation loop ---------
    let lastTime = performance.now();
    function performTick() {
      let energy = { kinetic: 0, potential: 0 };
      if (scaleMode === 'lattice') {
        computeFields();
        if (gravityOn) {
          energy = gravityMode === 'naive' ? applyNaiveGravity() : applyRelationalGravity();
        }
        updateInstanceMatrices();
        applyOverlayColors();
        if (tick % 10 === 0) updateAgents();
      } else if (tick % 30 === 0) {
        updateAgents();
      }
      tick++;

      if (scaleMode === 'lattice') {
        const totalE = energy.kinetic + energy.potential;
        if (energy0 === null && gravityOn) energy0 = Math.max(totalE, 0.0001);
        const drift = energy0 ? (totalE - energy0) / energy0 : 0;
        energyBreakdown.textContent = `${energy.kinetic.toFixed(3)}k / ${energy.potential.toFixed(3)}p / ${totalE.toFixed(3)}T`;
        energyDrift.textContent = drift.toFixed(4);
      } else {
        energyBreakdown.textContent = 'Lattice energy hidden';
        energyDrift.textContent = 'n/a';
      }
      tickLabel.textContent = tick.toString();
    }

    function animate(now) {
      const deltaMs = now - lastTime;
      lastTime = now;
      const delta = Math.min(0.1, deltaMs / 1000);
      if (running) {
        accumulated += delta * timeScale;
        simTime += delta * timeScale;
        while (accumulated >= FIXED_DT) {
          performTick();
          accumulated -= FIXED_DT;
        }
      }
      simtimeLabel.textContent = `${simTime.toFixed(2)}s`;
      if (scaleMode === 'solar_system') updateSolarSystem(simTime);
      if (scaleMode === 'galaxy') updateGalaxy(simTime);
      stars.rotation.y += 0.0004;
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // --------- Resize ---------
    window.addEventListener('resize', () => {
      const { clientWidth, clientHeight } = container;
      renderer.setSize(clientWidth, clientHeight);
      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
    });

    // --------- Boot ---------
    initSolarSystem();
    initGalaxy();
    populateSolarEditor();
    applyPreset('random');
    updateInspector(null);
    setScaleMode('lattice');
    requestAnimationFrame(animate);
  } catch (err) {
    console.error('PRU init failed', err);
  }
</script>
</body>
</html>
