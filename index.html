<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PRU Universe · Web Sandbox</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #05070c;
      --panel: #0f1219;
      --panel-border: #1f2430;
      --accent: #6ad8ff;
      --accent-2: #ff9f6b;
      --text: #d6e2ff;
      --muted: #7c8aa6;
      --green: #5ee1a5;
      --yellow: #ffd166;
      --red: #ff6b81;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0; padding: 0;
      height: 100%;
      background: radial-gradient(circle at top, #141b33 0%, var(--bg) 45%, #020308 100%);
      color: var(--text);
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    body { display: flex; overflow: hidden; }
    #scene-container { flex: 1; position: relative; }

    #overlay-title {
      position: absolute;
      top: 18px; left: 18px;
      background: rgba(5, 8, 16, 0.82);
      padding: 12px 14px;
      border-radius: 10px;
      border: 1px solid var(--panel-border);
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      backdrop-filter: blur(10px);
    }
    #overlay-title h1 {
      margin: 0;
      font-size: 22px;
      letter-spacing: 0.02em;
    }
    #overlay-title p {
      margin: 4px 0 0;
      color: var(--muted);
      font-size: 12px;
    }

    #panel {
      width: 380px;
      background: radial-gradient(circle at top, #151828 0%, var(--panel) 35%, #05060b 100%);
      border-left: 1px solid var(--panel-border);
      padding: 16px 16px 18px;
      overflow-y: auto;
      box-shadow: -12px 0 30px rgba(0,0,0,0.55);
    }

    .section {
      padding: 12px 0;
      border-bottom: 1px solid var(--panel-border);
    }
    .section:last-child { border-bottom: none; }
    .section h3 {
      margin: 0 0 6px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 11px;
      color: var(--muted);
    }

    .phase-row {
      display: flex;
      justify-content: space-between;
      margin: 4px 0;
      font-size: 13px;
    }

    .controls button {
      margin-right: 6px;
      margin-bottom: 6px;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--panel-border);
      background: #161a24;
      color: var(--text);
      cursor: pointer;
      transition: border-color 0.15s, background 0.15s, transform 0.08s;
      font-size: 13px;
    }
    .controls button:hover {
      border-color: var(--accent);
      background: #1b2434;
      transform: translateY(-1px);
    }
    .controls button:active {
      transform: translateY(0);
    }

    .controls .segmented {
      display: inline-flex;
      border: 1px solid var(--panel-border);
      border-radius: 10px;
      overflow: hidden;
      background: #111623;
      flex-wrap: wrap;
    }
    .controls .segmented button {
      margin: 0;
      border: none;
      border-right: 1px solid var(--panel-border);
      border-radius: 0;
      background: transparent;
      padding: 7px 10px;
      font-size: 12px;
    }
    .controls .segmented button:last-child { border-right: none; }
    .controls .segmented button.active {
      background: linear-gradient(135deg, #19324a, #132130);
      color: #cceaff;
    }

    label.small {
      display: block;
      font-size: 11px;
      color: var(--muted);
      margin: 6px 0 2px;
    }
    .toggle {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--panel-border);
      background: #161a24;
      width: 100%;
      text-align: left;
      cursor: pointer;
      font-size: 13px;
    }
    .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .row + .row { margin-top: 8px; }

    input[type=range] {
      width: 100%;
      accent-color: var(--accent);
    }

    .hud-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      font-size: 13px;
    }
    .hud-grid div {
      background: #0f1219;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid var(--panel-border);
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 6px;
    }
    .hud-grid strong { color: var(--accent-2); font-weight: 600; }

    #sparkline {
      width: 100%;
      height: 50px;
      background: #0c1018;
      border: 1px solid var(--panel-border);
      border-radius: 8px;
      margin-top: 4px;
      display: block;
    }

    #agents {
      background: #0f1219;
      border: 1px solid var(--panel-border);
      border-radius: 8px;
      padding: 8px 9px;
      height: 120px;
      overflow-y: auto;
      font-size: 13px;
      line-height: 1.4;
    }

    #inspector-details {
      background: #0f1219;
      border: 1px solid var(--panel-border);
      border-radius: 8px;
      padding: 8px 9px;
      font-size: 12px;
      line-height: 1.5;
      margin-top: 4px;
      white-space: pre-line;
    }

    .badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 11px;
      background: #162034;
      border: 1px solid var(--panel-border);
    }

    .text-muted { color: var(--muted); }
    .small-help p {
      margin: 4px 0;
      font-size: 11px;
      color: var(--muted);
    }
    a { color: var(--accent); }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="scene-container">
    <div id="overlay-title">
      <h1>PRU Universe · Web Sandbox</h1>
      <p>Precomputed Relational Universe (Three.js demo)</p>
    </div>
  </div>

  <aside id="panel">
    <div class="section" id="phase-status">
      <h3>Phase Status</h3>
      <div class="phase-row"><span>Phase 1: Core Scaffold</span><span>✅</span></div>
      <div class="phase-row"><span>Phase 2: Fields & Overlays</span><span>✅</span></div>
      <div class="phase-row"><span>Phase 3: Gravity & LSS</span><span>⏳</span></div>
      <div class="phase-row"><span>Phase 4: Stars & Agents</span><span>⏳</span></div>
      <div class="phase-row"><span>Phase 5: Time Control & Presets</span><span>TODO</span></div>
    </div>

    <div class="section controls" id="sim-controls">
      <h3>Simulation Controls</h3>
      <div>
        <button id="pause-btn">Pause</button>
        <button id="step-btn">Step</button>
      </div>
      <div>
        <button id="slower-btn">Slower</button>
        <button id="faster-btn">Faster</button>
      </div>
      <label class="small">Global time scale</label>
      <input type="range" id="timescale-slider" min="0.05" max="8" step="0.05" value="1.0">
      <div class="row"><span class="text-muted">Current</span><span id="timescale-label">1.0×</span></div>
    </div>

    <div class="section controls" id="presets">
      <h3>Experiment Presets</h3>
      <div class="segmented" id="preset-buttons">
        <button data-preset="random" class="active">Random Gas</button>
        <button data-preset="cluster">Central Cluster</button>
        <button data-preset="filaments">Cosmic Web</button>
        <button data-preset="shells">Voids & Shells</button>
      </div>
      <label class="small">Current preset: <span id="preset-label">Random Gas</span></label>
    </div>

    <div class="section controls" id="overlays">
      <h3>Overlays</h3>
      <div class="segmented" id="overlay-buttons">
        <button data-mode="base" class="active">Base</button>
        <button data-mode="density">Density</button>
        <button data-mode="curvature">Curvature</button>
      </div>
      <label class="small">Density from UA (mass lock)</label>
      <label class="small">Curvature from UB + neighbors</label>
    </div>

    <div class="section controls" id="gravity">
      <h3>Gravity</h3>
      <button class="toggle" id="gravity-toggle">Gravity: OFF</button>
      <label class="small">Mode</label>
      <div class="segmented" id="gravity-mode">
        <button data-mode="naive" class="active">Naive N-body</button>
        <button data-mode="relational">Relational Lattice</button>
      </div>
      <label class="small">G (constant)</label>
      <input type="range" id="g-slider" min="0.1" max="5" step="0.1" value="1.2">
      <div class="row"><span class="text-muted">Value</span><span id="g-label">1.2</span></div>
      <label class="small">Damping</label>
      <input type="range" id="damping-slider" min="0" max="0.2" step="0.005" value="0.02">
      <div class="row"><span class="text-muted">Value</span><span id="damping-label">0.02</span></div>
      <label class="small">Softening</label>
      <input type="range" id="softening-slider" min="0.1" max="3" step="0.1" value="1.0">
      <div class="row"><span class="text-muted">Value</span><span id="softening-label">1.0</span></div>
    </div>

    <div class="section" id="metrics">
      <h3>Metrics HUD</h3>
      <div class="hud-grid">
        <div><span>Tick</span><strong id="tick-label">0</strong></div>
        <div><span>Sim t</span><strong id="simtime-label">0.00s</strong></div>
        <div><span>Cells</span><strong id="cell-label">0</strong></div>
        <div><span>ΔE/E0</span><strong id="energy-drift">0</strong></div>
        <div><span>Avg ρ</span><strong id="density-avg">0</strong></div>
        <div><span>Min/Max ρ</span><strong id="density-minmax">0 / 0</strong></div>
        <div><span>Avg κ</span><strong id="curv-avg">0</strong></div>
        <div><span>Energy</span><strong id="energy-breakdown">0</strong></div>
      </div>
      <div class="row" style="margin-top:10px;">
        <span class="text-muted">Density sparkline</span>
        <span class="badge">Rolling avg</span>
      </div>
      <canvas id="sparkline" width="320" height="50"></canvas>
    </div>

    <div class="section" id="inspector-section">
      <h3>Cell Inspector</h3>
      <div class="text-muted" id="inspector-hint">Click a cell in the lattice to inspect its PRU state.</div>
      <div id="inspector-details">No cell selected.</div>
    </div>

    <div class="section" id="agents-section">
      <h3>Astro Agents (Phase 4 preview)</h3>
      <div id="agents"></div>
    </div>

    <div class="section" id="help">
      <h3>Help & Shortcuts</h3>
      <div class="small-help">
        <p>Space – Pause/Resume · . – Step · -/+ – Slower/Faster</p>
        <p>D/C – Density/Curvature overlays · G – Toggle gravity</p>
        <p>Click any cube to inspect its UA/UB, density, curvature & agent state.</p>
      </div>
    </div>
  </aside>

  <script type="module">
  import * as THREE from "https://unpkg.com/three@0.164.1/build/three.module.js";
  import { OrbitControls } from "https://unpkg.com/three@0.164.1/examples/jsm/controls/OrbitControls.js";

  try {
    // --------- Scene setup ---------
    const container = document.getElementById('scene-container');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setClearColor(new THREE.Color(0x05070c), 1);
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      55,
      container.clientWidth / container.clientHeight,
      0.1,
      2000
    );
    camera.position.set(34, 28, 36);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.maxDistance = 200;

    scene.add(new THREE.AmbientLight(0x8899ff, 0.5));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
    dirLight.position.set(40, 60, 35);
    scene.add(dirLight);

    // Background starfield
    const starGeo = new THREE.BufferGeometry();
    const starCount = 1400;
    const starPos = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
      const r = 220 * Math.pow(Math.random(), 0.45);
      const theta = Math.random() * 2 * Math.PI;
      const phi = Math.acos(2 * Math.random() - 1);
      starPos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
      starPos[i * 3 + 1] = r * Math.cos(phi);
      starPos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    const starMat = new THREE.PointsMaterial({
      size: 0.55,
      sizeAttenuation: true,
      transparent: true,
      opacity: 0.4
    });
    const stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);

    const grid = new THREE.GridHelper(120, 20, 0x1f2a3a, 0x111723);
    grid.position.y = -14;
    scene.add(grid);

    // --------- PRU lattice data ---------
    const GRID = 16;
    const CELL_SPACING = 1.1;
    const HALF = (GRID - 1) / 2;
    const cellCount = GRID * GRID * GRID;
    document.getElementById('cell-label').textContent = cellCount.toLocaleString();

    const ua = new Float32Array(cellCount);
    const ub = new Float32Array(cellCount);
    const density = new Float32Array(cellCount);
    const curvature = new Float32Array(cellCount);
    const basePositions = new Array(cellCount);
    const dynamicPositions = new Array(cellCount);

    const cellType = new Uint8Array(cellCount);
    const galaxyIds = new Int16Array(cellCount);

    function indexFromXYZ(x, y, z) {
      return x * GRID * GRID + y * GRID + z;
    }
    function xyzFromIndex(i) {
      const gx = Math.floor(i / (GRID * GRID));
      const gy = Math.floor((i % (GRID * GRID)) / GRID);
      const gz = i % GRID;
      return { x: gx, y: gy, z: gz };
    }

    let idx = 0;
    for (let x = 0; x < GRID; x++) {
      for (let y = 0; y < GRID; y++) {
        for (let z = 0; z < GRID; z++) {
          const px = (x - HALF) * CELL_SPACING;
          const py = (y - HALF) * CELL_SPACING;
          const pz = (z - HALF) * CELL_SPACING;
          const pos = new THREE.Vector3(px, py, pz);
          basePositions[idx] = pos.clone();
          dynamicPositions[idx] = pos.clone();
          idx++;
        }
      }
    }

    // Instanced mesh for cells
    const boxGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
    const boxMat = new THREE.MeshStandardMaterial({
      color: 0x66aaff,
      metalness: 0.1,
      roughness: 0.35,
      transparent: true,
      opacity: 0.9,
      vertexColors: true
    });
    const instanced = new THREE.InstancedMesh(boxGeo, boxMat, cellCount);
    instanced.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    instanced.instanceColor = new THREE.InstancedBufferAttribute(
      new Float32Array(cellCount * 3),
      3
    );
    instanced.geometry.setAttribute('instanceColor', instanced.instanceColor);
    scene.add(instanced);

    // Selection highlight
    const highlight = new THREE.Mesh(
      new THREE.BoxGeometry(0.82, 0.82, 0.82),
      new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true })
    );
    highlight.visible = false;
    highlight.renderOrder = 10;
    scene.add(highlight);
    let selectedIndex = null;

    function updateInstanceMatrices() {
      const dummy = new THREE.Object3D();
      for (let i = 0; i < cellCount; i++) {
        const p = dynamicPositions[i];
        dummy.position.copy(p);
        dummy.rotation.y = (ua[i] + ub[i]) * Math.PI * 0.2;
        dummy.updateMatrix();
        instanced.setMatrixAt(i, dummy.matrix);
      }
      instanced.instanceMatrix.needsUpdate = true;
      if (selectedIndex !== null) {
        highlight.position.copy(dynamicPositions[selectedIndex]);
        highlight.visible = true;
      }
    }

    // --------- Gravity data (naive subset) ---------
    const particleIndices = new Set();
    while (particleIndices.size < 230) {
      particleIndices.add(Math.floor(Math.random() * cellCount));
    }
    const particleVel = new Map();
    particleIndices.forEach(i => {
      particleVel.set(
        i,
        new THREE.Vector3((Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1)
      );
    });
    console.log('PRU lattice initialized', { GRID, cellCount });
    console.log('Particle subset size', particleIndices.size);

    // --------- HUD elements ---------
    const tickLabel = document.getElementById('tick-label');
    const simtimeLabel = document.getElementById('simtime-label');
    const timescaleLabel = document.getElementById('timescale-label');
    const timescaleSlider = document.getElementById('timescale-slider');
    const densityAvgLabel = document.getElementById('density-avg');
    const densityMinMaxLabel = document.getElementById('density-minmax');
    const curvAvgLabel = document.getElementById('curv-avg');
    const energyBreakdown = document.getElementById('energy-breakdown');
    const energyDrift = document.getElementById('energy-drift');
    const agentsDiv = document.getElementById('agents');
    const presetLabel = document.getElementById('preset-label');
    const inspectorDetails = document.getElementById('inspector-details');

    const sparkCanvas = document.getElementById('sparkline');
    const sparkCtx = sparkCanvas.getContext('2d');
    const sparkHistory = [];
    function drawSparkline() {
      const w = sparkCanvas.width;
      const h = sparkCanvas.height;
      sparkCtx.clearRect(0, 0, w, h);
      sparkCtx.fillStyle = '#0c1018';
      sparkCtx.fillRect(0, 0, w, h);
      sparkCtx.strokeStyle = '#2e3b52';
      sparkCtx.lineWidth = 1;
      sparkCtx.beginPath();
      sparkCtx.moveTo(0, h - 12);
      sparkCtx.lineTo(w, h - 12);
      sparkCtx.stroke();
      if (sparkHistory.length < 2) return;
      const max = Math.max(...sparkHistory);
      const min = Math.min(...sparkHistory);
      sparkCtx.strokeStyle = '#6ad8ff';
      sparkCtx.lineWidth = 2;
      sparkCtx.beginPath();
      sparkHistory.forEach((v, i) => {
        const x = (i / (sparkHistory.length - 1)) * w;
        const norm = (v - min) / (max - min + 1e-5);
        const y = h - 4 - norm * (h - 12);
        if (i === 0) sparkCtx.moveTo(x, y);
        else sparkCtx.lineTo(x, y);
      });
      sparkCtx.stroke();
    }

    // --------- Overlay coloring ---------
    const tempColor = new THREE.Color();
    let overlayMode = 'base';
    function applyOverlayColors() {
      for (let i = 0; i < cellCount; i++) {
        const d = density[i];
        const c = curvature[i];
        if (overlayMode === 'density') {
          const t = THREE.MathUtils.clamp(d, 0, 1);
          tempColor.setHSL(0.02 + 0.12 * t, 0.85, 0.28 + 0.32 * t);
        } else if (overlayMode === 'curvature') {
          const t = THREE.MathUtils.clamp((c + 0.5) / 1.0, 0, 1);
          tempColor.setHSL(0.58 - 0.48 * t, 0.85, 0.45 - 0.1 * (t - 0.5));
        } else {
          tempColor.setHSL(
            0.55 + 0.25 * (ub[i] - 0.5),
            0.45 + 0.35 * ua[i],
            0.32 + 0.22 * ua[i]
          );
        }
        instanced.setColorAt(i, tempColor);
      }
      instanced.instanceColor.needsUpdate = true;
    }

    // --------- Simulation state ---------
    let running = true;
    let tick = 0;
    let simTime = 0;
    let timeScale = 1.0;
    let accumulated = 0;
    const FIXED_DT = 0.02;

    let gravityOn = false;
    let gravityMode = 'naive';
    let G = parseFloat(document.getElementById('g-slider').value);
    let damping = parseFloat(document.getElementById('damping-slider').value);
    let softening = parseFloat(document.getElementById('softening-slider').value);

    let energy0 = null;

    // --------- Field computation ---------
    const neighborOffsets = [];
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dz = -1; dz <= 1; dz++) {
          if (dx === 0 && dy === 0 && dz === 0) continue;
          neighborOffsets.push([dx, dy, dz]);
        }
      }
    }

    function computeFields() {
      let avgDensity = 0;
      let minDensity = Infinity;
      let maxDensity = -Infinity;
      let avgCurv = 0;

      for (let x = 0; x < GRID; x++) {
        for (let y = 0; y < GRID; y++) {
          for (let z = 0; z < GRID; z++) {
            const i = indexFromXYZ(x, y, z);
            density[i] = ua[i];
            let sum = 0;
            let count = 0;
            for (const [dx, dy, dz] of neighborOffsets) {
              const nx = x + dx;
              const ny = y + dy;
              const nz = z + dz;
              if (nx < 0 || ny < 0 || nz < 0 || nx >= GRID || ny >= GRID || nz >= GRID) continue;
              const ni = indexFromXYZ(nx, ny, nz);
              sum += ub[ni];
              count++;
            }
            const neighborAvg = count > 0 ? sum / count : ub[i];
            curvature[i] = ub[i] - neighborAvg;

            const d = density[i];
            avgDensity += d;
            minDensity = Math.min(minDensity, d);
            maxDensity = Math.max(maxDensity, d);
            avgCurv += curvature[i];
          }
        }
      }

      avgDensity /= cellCount;
      avgCurv /= cellCount;

      densityAvgLabel.textContent = avgDensity.toFixed(3);
      densityMinMaxLabel.textContent = `${minDensity.toFixed(3)} / ${maxDensity.toFixed(3)}`;
      curvAvgLabel.textContent = avgCurv.toFixed(4);

      sparkHistory.push(avgDensity);
      if (sparkHistory.length > 80) sparkHistory.shift();
      drawSparkline();
    }

    // --------- Gravity ---------
    function applyNaiveGravity() {
      const ids = [...particleIndices];
      const forces = ids.map(() => new THREE.Vector3());
      let kinetic = 0;
      let potential = 0;
      for (let a = 0; a < ids.length; a++) {
        for (let b = a + 1; b < ids.length; b++) {
          const ia = ids[a];
          const ib = ids[b];
          const pa = dynamicPositions[ia];
          const pb = dynamicPositions[ib];
          const delta = new THREE.Vector3().subVectors(pb, pa);
          const distSq = Math.max(delta.lengthSq(), softening * softening);
          const invDist = 1 / Math.sqrt(distSq);
          const forceMag = (G * ua[ia] * ua[ib]) / distSq;
          const dir = delta.multiplyScalar(invDist);
          const f = dir.clone().multiplyScalar(forceMag);
          forces[a].add(f);
          forces[b].sub(f);
          potential -= G * ua[ia] * ua[ib] * invDist;
        }
      }
      for (let k = 0; k < ids.length; k++) {
        const i = ids[k];
        const vel = particleVel.get(i) || new THREE.Vector3();
        vel.add(forces[k].multiplyScalar(FIXED_DT));
        vel.multiplyScalar(1 - damping);
        particleVel.set(i, vel);
        dynamicPositions[i].add(vel.clone().multiplyScalar(FIXED_DT));
        kinetic += 0.5 * vel.lengthSq();
      }
      return { kinetic, potential };
    }

    function applyRelationalGravity() {
      const temp = new THREE.Vector3();
      let kinetic = 0.05;
      let potential = 0.05;
      for (let x = 1; x < GRID - 1; x++) {
        for (let y = 1; y < GRID - 1; y++) {
          for (let z = 1; z < GRID - 1; z++) {
            const i = indexFromXYZ(x, y, z);
            const gradX = density[indexFromXYZ(x + 1, y, z)] - density[indexFromXYZ(x - 1, y, z)];
            const gradY = density[indexFromXYZ(x, y + 1, z)] - density[indexFromXYZ(x, y - 1, z)];
            const gradZ = density[indexFromXYZ(x, y, z + 1)] - density[indexFromXYZ(x, y, z - 1)];
            temp.set(gradX, gradY, gradZ).multiplyScalar(G * 0.05);
            dynamicPositions[i].add(temp);
            dynamicPositions[i].lerp(basePositions[i], damping * 0.5);
          }
        }
      }
      return { kinetic, potential };
    }

    // --------- Agents ---------
    let galaxyCounter = 0;
    function updateAgents() {
      cellType.fill(0);
      galaxyIds.fill(-1);
      const starThreshold = 0.82;
      const bhDensityThreshold = 0.9;
      const bhCurvThreshold = 0.12;

      const bins = new Map();
      for (let i = 0; i < cellCount; i++) {
        const d = density[i];
        const k = curvature[i];
        if (d > bhDensityThreshold && k > bhCurvThreshold) {
          cellType[i] = 2;
        } else if (d > starThreshold) {
          cellType[i] = 1;
        }
        if (cellType[i] > 0) {
          const p = basePositions[i];
          const key = `${Math.round(p.x / 6)},${Math.round(p.y / 6)},${Math.round(p.z / 6)}`;
          if (!bins.has(key)) bins.set(key, []);
          bins.get(key).push(i);
        }
      }

      let html = '';
      let gid = 1;
      bins.forEach(indices => {
        if (indices.length >= 8) {
          let stars = 0;
          let bh = 0;
          let mass = 0;
          indices.forEach(i => {
            if (cellType[i] === 1) stars++;
            if (cellType[i] === 2) bh++;
            mass += ua[i];
            galaxyIds[i] = gid;
          });
          const massDelta = ((mass / indices.length - 0.5) * 100).toFixed(1);
          html += `Agent G-${gid}: ${stars} stars, ${bh} BH cores, mass ${massDelta}%<br>`;
          gid++;
        }
      });
      galaxyCounter = gid - 1;
      if (!html) {
        html = '<span class="text-muted">No active clusters. Halos stabilizing...</span>';
      }
      agentsDiv.innerHTML = html;
    }

    // --------- Inspector ---------
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    function updateInspector(i) {
      if (i === null || i === undefined) {
        inspectorDetails.textContent = 'No cell selected.';
        return;
      }
      const { x, y, z } = xyzFromIndex(i);
      const pos = dynamicPositions[i];
      const uaVal = ua[i];
      const ubVal = ub[i];
      const d = density[i];
      const k = curvature[i];
      const type = cellType[i] === 2 ? 'Black-hole seed' : cellType[i] === 1 ? 'Star cell' : 'Gas / background cell';
      const galaxy = galaxyIds[i] > 0 ? `G-${galaxyIds[i]}` : 'None';
      inspectorDetails.textContent = `Index ${i} ( ${x}, ${y}, ${z} )
World: (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})
UA ${uaVal.toFixed(3)} · UB ${ubVal.toFixed(3)}
Density ${d.toFixed(4)} · Curvature ${k.toFixed(4)}
Class: ${type}
Galaxy: ${galaxy}`;
      selectedIndex = i;
      highlight.visible = true;
      highlight.position.copy(pos);
    }

    function onPointerDown(event) {
      if (event.button !== 0) return;
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObject(instanced);
      if (intersects.length > 0 && intersects[0].instanceId !== undefined) {
        updateInspector(intersects[0].instanceId);
      }
    }
    renderer.domElement.addEventListener('pointerdown', onPointerDown);

    // --------- Presets ---------
    const presetButtonsDiv = document.getElementById('preset-buttons');

    function resetSimState() {
      tick = 0;
      simTime = 0;
      accumulated = 0;
      energy0 = null;
      sparkHistory.length = 0;
      drawSparkline();
      tickLabel.textContent = '0';
      simtimeLabel.textContent = '0.00s';
      energyBreakdown.textContent = '0';
      energyDrift.textContent = '0';
    }

    function applyPreset(name) {
      for (let i = 0; i < cellCount; i++) {
        const p = basePositions[i];
        const r = p.length() / (HALF * CELL_SPACING * 1.25);
        const noise = Math.random() * 0.08;
        if (name === 'cluster') {
          const core = Math.exp(-r * r * 2.2);
          ua[i] = THREE.MathUtils.clamp(core + noise, 0, 1);
          ub[i] = THREE.MathUtils.clamp(0.55 + (0.6 - r) * 0.6 + (Math.random() - 0.5) * 0.12, 0, 1);
        } else if (name === 'filaments') {
          const axis = Math.min(Math.abs(p.x), Math.abs(p.z));
          const spine = Math.exp(-(axis * axis) / 35);
          const layer = Math.exp(-(Math.abs(p.y) * Math.abs(p.y)) / 28);
          ua[i] = THREE.MathUtils.clamp(spine * layer + noise * 0.9, 0, 1);
          ub[i] = THREE.MathUtils.clamp(0.4 + (p.y / (HALF * CELL_SPACING)) * 0.35 + (Math.random() - 0.5) * 0.18, 0, 1);
        } else if (name === 'shells') {
          const r0 = 0.6;
          const shell = Math.exp(-((r - r0) * (r - r0)) * 18);
          ua[i] = THREE.MathUtils.clamp(shell + noise * 0.8, 0, 1);
          ub[i] = THREE.MathUtils.clamp(r * 0.9 + (Math.random() - 0.5) * 0.15, 0, 1);
        } else {
          ua[i] = Math.random();
          ub[i] = Math.random();
        }
        dynamicPositions[i].copy(basePositions[i]);
      }
      particleVel.forEach(v => v.set(0, 0, 0));
      resetSimState();
      computeFields();
      updateInstanceMatrices();
      applyOverlayColors();
      updateAgents();

      presetLabel.textContent =
        name === 'cluster'
          ? 'Central Cluster'
          : name === 'filaments'
          ? 'Cosmic Web'
          : name === 'shells'
          ? 'Voids & Shells'
          : 'Random Gas';
      [...presetButtonsDiv.children].forEach(btn => btn.classList.toggle('active', btn.dataset.preset === name));
    }

    presetButtonsDiv.addEventListener('click', e => {
      if (e.target.tagName !== 'BUTTON') return;
      const preset = e.target.dataset.preset;
      applyPreset(preset);
    });

    // --------- UI wiring ---------
    const pauseBtn = document.getElementById('pause-btn');
    const stepBtn = document.getElementById('step-btn');
    const slowerBtn = document.getElementById('slower-btn');
    const fasterBtn = document.getElementById('faster-btn');

    pauseBtn.addEventListener('click', () => {
      running = !running;
      pauseBtn.textContent = running ? 'Pause' : 'Resume';
    });
    stepBtn.addEventListener('click', () => {
      if (!running) performTick();
    });
    slowerBtn.addEventListener('click', () => {
      timeScale = Math.max(0.05, timeScale / 1.5);
      timescaleSlider.value = timeScale.toFixed(2);
      timescaleLabel.textContent = `${timeScale.toFixed(2)}×`;
    });
    fasterBtn.addEventListener('click', () => {
      timeScale = Math.min(8, timeScale * 1.5);
      timescaleSlider.value = timeScale.toFixed(2);
      timescaleLabel.textContent = `${timeScale.toFixed(2)}×`;
    });
    timescaleSlider.addEventListener('input', () => {
      timeScale = parseFloat(timescaleSlider.value);
      timescaleLabel.textContent = `${timeScale.toFixed(2)}×`;
    });

    document.getElementById('overlay-buttons').addEventListener('click', e => {
      if (e.target.tagName !== 'BUTTON') return;
      overlayMode = e.target.dataset.mode;
      [...e.currentTarget.children].forEach(btn => btn.classList.toggle('active', btn === e.target));
      applyOverlayColors();
    });

    document.getElementById('gravity-toggle').addEventListener('click', e => {
      gravityOn = !gravityOn;
      e.target.textContent = gravityOn ? 'Gravity: ON' : 'Gravity: OFF';
      if (gravityOn && energy0 === null) energy0 = 0.0001;
    });
    document.getElementById('gravity-mode').addEventListener('click', e => {
      if (e.target.tagName !== 'BUTTON') return;
      gravityMode = e.target.dataset.mode;
      [...e.currentTarget.children].forEach(btn => btn.classList.toggle('active', btn === e.target));
    });
    const gSlider = document.getElementById('g-slider');
    const dampingSlider = document.getElementById('damping-slider');
    const softeningSlider = document.getElementById('softening-slider');
    const gLabel = document.getElementById('g-label');
    const dampingLabel = document.getElementById('damping-label');
    const softeningLabel = document.getElementById('softening-label');

    gSlider.addEventListener('input', () => {
      G = parseFloat(gSlider.value);
      gLabel.textContent = G.toFixed(2);
    });
    dampingSlider.addEventListener('input', () => {
      damping = parseFloat(dampingSlider.value);
      dampingLabel.textContent = damping.toFixed(3);
    });
    softeningSlider.addEventListener('input', () => {
      softening = parseFloat(softeningSlider.value);
      softeningLabel.textContent = softening.toFixed(1);
    });

    // Keyboard shortcuts
    window.addEventListener('keydown', e => {
      if (e.code === 'Space') {
        e.preventDefault();
        pauseBtn.click();
      } else if (e.key === '.') {
        if (!running) performTick();
      } else if (e.key === '-' || e.key === '_') {
        slowerBtn.click();
      } else if (e.key === '+' || e.key === '=') {
        fasterBtn.click();
      } else if (e.key.toLowerCase() === 'd') {
        overlayMode = 'density';
        document.querySelectorAll('#overlay-buttons button').forEach(btn =>
          btn.classList.toggle('active', btn.dataset.mode === 'density')
        );
        applyOverlayColors();
      } else if (e.key.toLowerCase() === 'c') {
        overlayMode = 'curvature';
        document.querySelectorAll('#overlay-buttons button').forEach(btn =>
          btn.classList.toggle('active', btn.dataset.mode === 'curvature')
        );
        applyOverlayColors();
      } else if (e.key.toLowerCase() === 'g') {
        document.getElementById('gravity-toggle').click();
      }
    });

    // --------- Simulation loop ---------
    let lastTime = performance.now();
    function performTick() {
      computeFields();
      let energy = { kinetic: 0, potential: 0 };
      if (gravityOn) {
        energy = gravityMode === 'naive' ? applyNaiveGravity() : applyRelationalGravity();
      }
      updateInstanceMatrices();
      applyOverlayColors();
      tick++;

      const totalE = energy.kinetic + energy.potential;
      if (energy0 === null) energy0 = Math.max(totalE, 0.0001);
      const drift = (totalE - energy0) / energy0;
      energyBreakdown.textContent = `${energy.kinetic.toFixed(3)}k / ${energy.potential.toFixed(3)}p / ${totalE.toFixed(3)}T`;
      energyDrift.textContent = drift.toFixed(4);
      tickLabel.textContent = tick.toString();

      if (tick % 10 === 0) updateAgents();
    }

    function animate(now) {
      const deltaMs = now - lastTime;
      lastTime = now;
      const delta = Math.min(0.1, deltaMs / 1000);
      if (running) {
        accumulated += delta * timeScale;
        simTime += delta * timeScale;
        while (accumulated >= FIXED_DT) {
          performTick();
          accumulated -= FIXED_DT;
        }
      }
      simtimeLabel.textContent = `${simTime.toFixed(2)}s`;
      stars.rotation.y += 0.0004;
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // --------- Resize ---------
    window.addEventListener('resize', () => {
      const { clientWidth, clientHeight } = container;
      renderer.setSize(clientWidth, clientHeight);
      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
    });

    // --------- Boot ---------
    applyPreset('random');
    updateInspector(null);
    requestAnimationFrame(animate);
  } catch (err) {
    console.error('PRU init failed', err);
  }
</script>
</body>
</html>
